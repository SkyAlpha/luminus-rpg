<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"PhaserWarp.js.html":{"id":"PhaserWarp.js.html","title":"Source: PhaserWarp.js","body":" Phaser Action RPG Classes PhaserWarpShowInfo Source: PhaserWarp.js import Phaser from 'phaser'; /** * @class */ export class PhaserWarp { /** * * @param {Phaser.Scene} scene Phaser scene that it will control. * @param {GameObject} player the game object that will be teleported to a certain spot. */ constructor(scene, player, map) { this.scene = scene; this.player = player; this.map = map; this.defaultFadeTime = 1000; this.fadeOutTime = this.defaultFadeTime; this.fadeInTime = this.defaultFadeTime; this.maxSpeed = this.player.body.maxSpeed; this.warpObjectName = 'warps'; // Default name of the warps object created in the Tiled Software. } createWarps() { const warps = this.map.getObjectLayer(this.warpObjectName); const warp_array = warps.objects.filter((obj) =&gt; obj.properties); const destinations = warps.objects.filter((obj) =&gt; !obj.properties); const warp_points = []; warp_array.forEach((warp) =&gt; { // For log purpposes // let rect = this.add.rectangle( // warp.x, // warp.y, // warp.width, // warp.height, // 0xffff00, // 0.5 // ); let zone = this.scene.add.zone( warp.x, warp.y, warp.width, warp.height ); this.scene.physics.add.existing(zone); zone.body.immovable = true; // Prevents it from moving on collision. zone.setOrigin(0, 0); warp_points.push({ ...zone, warp }); }); this.scene.cameras.main.on('camerafadeoutstart', (fade) =&gt; { // Stop moving. this.player.body.maxSpeed = 0; }); this.scene.cameras.main.on('camerafadeincomplete', (fade) =&gt; { this.player.body.maxSpeed = this.maxSpeed; }); // Sets the collision between the player and the waro points. this.scene.physics.add.collider( warp_points, this.player, (warp_point, player) =&gt; { const dest = destinations.find( (d) =&gt; d.id === warp_point.warp.properties[0].value ); this.scene.cameras.main.fade(this.fadeOutTime); if (dest) { player.x = dest.x; player.y = dest.y; this.scene.cameras.main.fadeIn(this.fadeInTime); } } ); } } × Search results Close "},"ShowInfo.js.html":{"id":"ShowInfo.js.html","title":"Source: ShowInfo.js","body":" Phaser Action RPG Classes PhaserWarpShowInfo Source: ShowInfo.js import Phaser from 'phaser'; /** * @class */ export class ShowInfo { /** * This class allows one to create Dialogs with \"Tiled\" map editor &lt;a href=\"https://www.mapeditor.org/\"&gt;Tiled&lt;/a&gt; * Using the Objects layer https://doc.mapeditor.org/en/stable/manual/objects/ and open them * seemlessly with phaser. * * You should a game object to check if it overlaps your dialog information. * * Simply put, It Creates a Dialog to show messages from static objects created with \"Tiled\". * @param {Phaser.Scene} scene Scene Context. * @param {Phaser.GameObjects} player Player Game Object. * @param {Phaser.Tilemaps.Tilemap} map Tile Map to get the object from. */ constructor(scene, player, map) { /** * scene Scene Context. * @type {Phaser.Scene} */ this.scene = scene; /** * player Player Game Object. * @type {Phaser.GameObjects} */ this.player = player; // Player to compare overlaps. /** * Tile Map to get the object from. * @type {Phaser.Tilemaps.Tilemap} */ this.map = map; /** * Name of the object Layer in the \"Tiled\" software. &lt;a href=\"https://www.mapeditor.org/\"&gt;Tiled&lt;/a&gt; * Check Tiled Docs to learn more &lt;a href=\"https://doc.mapeditor.org/en/stable/manual/objects/\"&gt;Tiled&lt;/a&gt; * @type {string} */ this.tiledObjectLayer = 'info'; /** * Name of the sprite image that will be the dialog. * @type {string} */ this.dialogSpriteName = 'dialog'; /** * Name of the Sprite of the button action. * @type {string} */ this.actionButtonSprite = 'space'; /** * Object Attribute that the you created in the Tiled Software * @type {string} */ this.messageAttribute = 'message'; /** * Current action button key code. * @type {Phaser.Input.Keyboard.KeyCodes} */ this.actionButtonKeyCode = Phaser.Input.Keyboard.KeyCodes.SPACE; /** * Dialog height. * @type {number} */ this.dialog_height = 150; // Dialog Height /** * Margin of the dialog. Used to make spaces in the dialog. * @type {number} */ this.margin = 15; /** * Width and Height of the corner Slice. * @example * this.nineSliceOffsets = 25; * // Or * this.nineSliceOffsets = [10, 15, 5, 5]; * @ * // Array Length Use Explanation * // 1 [ topRightBottomLeft ] The first (only) element is used as the value for all four sides * // 2 [ topBottom, leftRight ] The first element is used for the top and bottom, the second element is used as the for the left and right * // 3 [ top, rightLeft, bottom ] The first element is used for the top, second is used for the right and left, and the third element is used for the bottom * // 4 [ top, right, bottom, left ] Each element is assigned to a specific side * @type {number | Array&lt;number&gt;} */ this.nineSliceOffsets = 23; this.nineSliceSafeArea = 12; this.actionSpriteScale = 0.5; this.dialogSpeed = 200; this.fontSize = 20; this.dialogMaxLines = 5; this.letterSpacing = 0; this.textWidth = this.scene.cameras.main.width - this.margin * 3; // Defines the text Width. this.canShowDialog = true; this.isOverlapingChat = false; this.isAnimatingText = false; } create() { this.dialog = this.scene.add.nineslice( this.margin, this.scene.cameras.main.height - this.dialog_height - this.margin, // this is the starting x/y location this.scene.cameras.main.width - this.margin * 2, this.dialog_height, // the width and height of your object this.dialogSpriteName, // a key to an already loaded image this.nineSliceOffsets, // the width and height to offset for a corner slice this.nineSliceSafeArea // (optional) pixels to offset when computing the safe usage area ); this.dialog.setScrollFactor(0, 0); this.dialog.depth = 99; this.dialog.visible = false; this.actionButton = this.scene.add .image( this.scene.cameras.main.width - this.margin * 3, this.scene.cameras.main.height - // this.dialog_height - this.margin * 3, this.actionButtonSprite ) .setDepth(9999) .setScrollFactor(0, 0) .setScale(this.actionSpriteScale); this.actionButton.visible = false; this.scene.tweenKey = this.scene.add.tween({ targets: this.actionButton, yoyo: true, repeat: -1, scale: { from: this.actionSpriteScale, to: 0.4 }, duration: 1000, }); this.dialog.zone = this.scene.add .zone( this.margin, this.scene.cameras.main.height - this.dialog_height - this.margin, // this is the starting x/y location this.scene.cameras.main.width - this.margin * 2, this.dialog_height ) .setInteractive() .setOrigin(0, 0); this.dialog.zone.setScrollFactor(0, 0); this.dialog.zone.depth = 999; this.dialog.zone.on('pointerdown', (pointer) =&gt; { if (this.dialog.textMessage &amp;&amp; this.dialog.textMessage.active) { console.log(this.dialog.textMessage.active); this.dialog.textMessage.destroy(); this.dialog.visible = false; this.canShowDialog = true; console.log(this.player.body.checkCollision); } }); // Rules to show informations! const infoObjects = this.map.getObjectLayer(this.tiledObjectLayer); let zones = []; infoObjects.objects.forEach((infoObj) =&gt; { let zone = this.scene.add.zone( infoObj.x, infoObj.y, infoObj.width, infoObj.height ); this.scene.physics.add.existing(zone); zone.setOrigin(0, 0); zone.body.immovable = true; zones.push({ ...zone, message: infoObj.properties[0].value }); }); /** * Checks if the player is overlapping the Tiled map Zone. */ this.scene.physics.add.overlap( zones, this.player, (zone) =&gt; { this.isOverlapingChat = true; this.actionButton.visible = true; this.dialogMessage = zone.message; }, (d) =&gt; { return this.canShowDialog; } ); this.keyObj = this.scene.input.keyboard.addKey( this.actionButtonKeyCode ); this.scene.input.keyboard.on('keydown', (key) =&gt; { if ( this.isOverlapingChat &amp;&amp; this.keyObj.isDown &amp;&amp; !this.dialog.visible ) { this.showDialog(); } else if (this.isAnimatingText &amp;&amp; this.keyObj.isDown) { this.setText(this.dialogMessage, false); } else if ( this.keyObj.isDown &amp;&amp; this.dialog.visible &amp;&amp; this.dialog.textMessage &amp;&amp; this.dialog.textMessage.active ) { this.dialog.textMessage.destroy(); this.dialog.visible = false; this.canShowDialog = true; } }); } /** * Shows the dialog with the message from the zone it's overlaping. * Make sure you have only one overlaping zone with the player. */ showDialog() { this.actionButton.visible = false; this.dialog.visible = true; this.canShowDialog = false; const maxLettersPage = Math.floor(this.textWidth / this.fontSize) * this.dialogMaxLines; this.pageNumber = Math.ceil(this.dialogMessage.length / maxLettersPage); console.log('Max pages', this.pageNumber); this.dialog.textMessage = this.scene.add .text( this.margin * 2, this.scene.cameras.main.height + this.margin / 2 - this.dialog_height, '', { wordWrap: { width: this.textWidth, }, wordWrapUseAdvanced: false, fontSize: this.fontSize, maxLines: this.dialogMaxLines, letterSpacing: this.letterSpacing, fontFamily: 'Arial, monospace', } ) .setScrollFactor(0, 0) .setDepth(99999999999999999) .setFixedSize( this.scene.cameras.main.width - this.margin * 3, this.dialog_height ); // Animates the text this.setText(this.dialogMessage, true); } /** * Sets the text for the dialog window. * @param { string } text The text string to be shown in the dialog. * @param { boolean } animate Rather it should animate the text or not. If it's false, it will stop the animation text in process. */ setText(text, animate = false) { // Reset the dialog this.eventCounter = 0; this.animationText = text.split(''); console.log(this.animationText); if (this.timedEvent) this.timedEvent.remove(); // var tempText = animate ? '' : text; // this.setText(tempText); if (animate) { this.isAnimatingText = true; this.timedEvent = this.scene.time.addEvent({ delay: Math.floor(1000 / this.dialogSpeed), callback: this.animateText, callbackScope: this, loop: true, }); } else { if (this.timedEvent) this.timedEvent.remove(); this.isAnimatingText = false; this.dialog.textMessage.text = text; } } /** * Slowly displays the text in the window to make it appear annimated * */ animateText() { this.eventCounter++; this.dialog.textMessage.setText( this.dialog.textMessage.text + this.animationText[this.eventCounter - 1] ); // Stops the text animation. if (this.eventCounter === this.animationText.length) { this.isAnimatingText = false; this.timedEvent.remove(); } } /** * Checks if the player is moving. * @returns { boolean } */ isMoving() { // If is colliding should always show the trigger button. // Pressing space button, should show the chat. return ( this.player.body.velocity.x !== 0 || this.player.body.velocity.y !== 0 ); } /** * Checks if the player is still overlaping the zone. * Hides the action button if it's not overlaping the zone. */ checkUpdate() { if ( this.actionButton &amp;&amp; this.isMoving() &amp;&amp; this.player.body.touching.none &amp;&amp; this.isOverlapingChat ) { this.actionButton.visible = false; this.isOverlapingChat = false; } } } × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Phaser Action RPG Classes PhaserWarpShowInfo Classes Classes PhaserWarp ShowInfo × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Phaser Action RPG Classes PhaserWarpShowInfo × Search results Close "},"PhaserWarp.html":{"id":"PhaserWarp.html","title":"Class: PhaserWarp","body":" Phaser Action RPG Classes PhaserWarpShowInfo Class: PhaserWarp PhaserWarp new PhaserWarp(scene, player) Parameters: Name Type Description scene Phaser.Scene Phaser scene that it will control. player GameObject the game object that will be teleported to a certain spot. Source: PhaserWarp.js, line 6 Classes PhaserWarp × Search results Close "},"ShowInfo.html":{"id":"ShowInfo.html","title":"Class: ShowInfo","body":" Phaser Action RPG Classes PhaserWarpShowInfo Class: ShowInfo ShowInfo new ShowInfo(scene, player, map) This class allows one to create Dialogs with \"Tiled\" map editor Tiled Using the Objects layer https://doc.mapeditor.org/en/stable/manual/objects/ and open them seemlessly with phaser. You should a game object to check if it overlaps your dialog information. Simply put, It Creates a Dialog to show messages from static objects created with \"Tiled\". Parameters: Name Type Description scene Phaser.Scene Scene Context. player Phaser.GameObjects Player Game Object. map Phaser.Tilemaps.Tilemap Tile Map to get the object from. Source: ShowInfo.js, line 6 Classes ShowInfo Members actionButtonKeyCode :Phaser.Input.Keyboard.KeyCodes Current action button key code. Type: Phaser.Input.Keyboard.KeyCodes Source: ShowInfo.js, line 52 actionButtonSprite :string Name of the Sprite of the button action. Type: string Source: ShowInfo.js, line 44 dialog_height :number Dialog height. Type: number Source: ShowInfo.js, line 56 dialogSpriteName :string Name of the sprite image that will be the dialog. Type: string Source: ShowInfo.js, line 40 map :Phaser.Tilemaps.Tilemap Tile Map to get the object from. Type: Phaser.Tilemaps.Tilemap Source: ShowInfo.js, line 31 margin :number Margin of the dialog. Used to make spaces in the dialog. Type: number Source: ShowInfo.js, line 60 messageAttribute :string Object Attribute that the you created in the Tiled Software Type: string Source: ShowInfo.js, line 48 nineSliceOffsets :number|Array.&lt;number&gt; Width and Height of the corner Slice. Type: number | Array.&lt;number&gt; Source: ShowInfo.js, line 74 Example this.nineSliceOffsets = 25; // Or this.nineSliceOffsets = [10, 15, 5, 5]; @ // Array Length Use Explanation // 1 [ topRightBottomLeft ] The first (only) element is used as the value for all four sides // 2 [ topBottom, leftRight ] The first element is used for the top and bottom, the second element is used as the for the left and right // 3 [ top, rightLeft, bottom ] The first element is used for the top, second is used for the right and left, and the third element is used for the bottom // 4 [ top, right, bottom, left ] Each element is assigned to a specific side player :Phaser.GameObjects player Player Game Object. Type: Phaser.GameObjects Source: ShowInfo.js, line 27 scene :Phaser.Scene scene Scene Context. Type: Phaser.Scene Source: ShowInfo.js, line 23 tiledObjectLayer :string Name of the object Layer in the \"Tiled\" software. Tiled Check Tiled Docs to learn more Tiled Type: string Source: ShowInfo.js, line 36 Methods animateText() Slowly displays the text in the window to make it appear annimated Source: ShowInfo.js, line 278 checkUpdate() Checks if the player is still overlaping the zone. Hides the action button if it's not overlaping the zone. Source: ShowInfo.js, line 308 isMoving() Checks if the player is moving. Source: ShowInfo.js, line 295 Returns: Type boolean setText(text, animate) Sets the text for the dialog window. Parameters: Name Type Default Description text string The text string to be shown in the dialog. animate boolean false Rather it should animate the text or not. If it's false, it will stop the animation text in process. Source: ShowInfo.js, line 250 showDialog() Shows the dialog with the message from the zone it's overlaping. Make sure you have only one overlaping zone with the player. Source: ShowInfo.js, line 207 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
